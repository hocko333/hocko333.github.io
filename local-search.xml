<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>优雅处理 async/await 中的异常</title>
    <link href="/2022/01/26/%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86async-await%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/01/26/%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86async-await%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="优雅处理-async-await-中的异常"><a href="#优雅处理-async-await-中的异常" class="headerlink" title="优雅处理 async/await 中的异常"></a>优雅处理 async/await 中的异常</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，你是否会为了代码鲁棒性，亦或者是为了捕获异步的错误，而频繁的在 <code>async</code> 函数中写 <code>try/catch</code> 的逻辑？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> asyncFunc()<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//......</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>曾有人提过这样一个处理 <code>async/await</code> 的方法</p><p><img src="/img/post-async-await/error_captured.webp" alt="errorCaptured"></p><p>这样我们就可以使用一个辅助函数包裹这个 <code>async</code> 函数实现错误捕获</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [err, res] = <span class="hljs-keyword">await</span> errorCaptured(asyncFunc)<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-comment">//... 错误捕获</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这么做有一个缺陷就是每次使用的时候，都要引入 <code>errorCaptured</code> 这个辅助函数，有没有“懒”的方法呢？</p><p>答案肯定是有的，可以通过一个 <code>webpack loader</code> 来自动注入 <code>try/catch</code> 代码，最后的结果希望是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// development</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> asyncFunc()<br>  <span class="hljs-comment">//...其他逻辑</span><br>&#125;<br><br><span class="hljs-comment">// release</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> asyncFunc()<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">//......</span><br>  &#125;<br>  <span class="hljs-comment">//...其他逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是很棒？在开发环境中不需要任何多余的代码，让 <code>webpack</code> 自动给生产环境的代码注入错误捕获的逻辑，接下来我们来逐步实现这个 <code>loader</code></p><h2 id="loader-原理"><a href="#loader-原理" class="headerlink" title="loader 原理"></a>loader 原理</h2><p>在实现这个 <code>webpack loader</code> 之前，先简要介绍一下 <code>loader</code> 的原理，我们在 <code>webpack</code> 中定义的一个 <code>loader</code>，本质上只是一个函数，在定义 <code>loader</code> 同时还会定义一个 <code>test</code> 属性，<code>webpack</code> 会遍历所有的模块名，当匹配 <code>test</code> 属性定义的正则时，会将这个模块作为 <code>source</code> 参数传入 <code>loader</code> 中执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>,<br>  use: <span class="hljs-string">&quot;vue-loader&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>当匹配到 <code>.vue</code> 结尾的文件名时，会将文件作为 <code>source</code> 参数传给 <code>vue-loader</code>，<code>use</code> 属性后面可以是一个字符串也可以是一个路径，当是字符串时默认会视为 <code>nodejs 模块</code>，去 <code>node_modules</code> 中找</p><p>而这些文件本质上其实就是字符串（图片、视频就是 Buffer 对象），以 <code>vue-loader</code> 为例，当 <code>loader</code> 接受到文件时，通过字符串匹配将其分为 3 份，模版部分会被 <code>vue-loader</code> 编译为 <code>render</code> 函数，<code>script</code> 部分会交给 <code>babel-loader</code>，<code>style</code> 部分会交给 <code>css-loader</code>，同时 <code>loader</code> 遵守单一原则，即一个 <code>loader</code> 只做一件事，这样可以灵活组合多个 <code>loader</code>，互不干扰</p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>因为 <code>loader</code> 可以读取匹配到的文件，经过处理变成期望的输出结果，所以我们可以自己实现一个 <code>loader</code>，接受 <code>js</code> 文件，当遇到 <code>await</code> 关键字时，给代码包裹一层 <code>try/catch</code></p><p>那么如何能够准确给 <code>await</code> 及后面的表达式包裹 <code>try/catch</code> 呢？这里需要用到<code>抽象语法树（AST）</code>相关的知识</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><blockquote><p>抽象语法树是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构</p></blockquote><p>通过 <code>AST</code> 可以实现很多非常有用的功能，例如将 <code>ES6+</code> 的代码转为 <code>ES5</code>，<code>eslint</code> 的检查，代码美化，甚至 js 引擎都是依赖 <code>AST</code> 实现的，同时因为代码本质只是单纯的字符串，所以并不仅限于 <code>js</code> 之间的转换，<code>scss</code>，<code>less</code> 等 <code>css</code> 预处理器也是通过 <code>AST</code> 转为浏览器认识的 <code>css</code> 代码，我们来举个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> b = a + <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>将其转换为抽象语法树后是这样的</p><p><img src="/img/post-async-await/ast-1.webp" alt="AST 01"></p><p>将字符串转为 <code>AST</code> 树需要经过词法分析和语法分析两步</p><p>词法分析将一个个代码片段转为 <code>token</code>（词法单元），去除空格注释，例如第一行会将 <code>let</code>，<code>a</code>，<code>=</code>，<code>1</code> 这 4 个转为 <code>token</code>，<code>token</code> 是一个对象，描述了代码片段在整个代码中的位置和记录当前值的一些信息</p><p><img src="/img/post-async-await/ast-2.webp" alt="AST 02"></p><p>语法分析会将 <code>token</code> 结合当前语言<code>（JS）</code>的语法转换成 <code>Node（节点）</code>，同时 <code>Node</code> 包含一个 <code>type</code> 属性记录当前的类型，例如 <code>let</code> 在 <code>JS</code> 中代表着一个变量声明的关键字，所以它的 <code>type</code> 为 <code>VariableDeclaration</code>，而 <code>a = 1</code> 会作为 <code>let</code> 的声明描述，它的 <code>type</code> 为 <code>VariableDeclarator</code>，而声明描述是依赖于变量声明的，所以是一种上下的层级关系</p><p>另外可以发现并不是一个 <code>token</code> 对应一个 <code>Node</code>，等号左右必须都有值才能组成一个声明语句，否则会作出警告，这就是 <code>eslint</code> 的基本原理。最后所有的 <code>Node</code> 组合在一起就形成了 <code>AST 语法树</code></p><p><strong>推荐一个很实用的 AST 查看工具，<a href="https://astexplorer.net/#/Z1exs6BWMq">AST explorer</a>，更直观的查看代码是如何转为抽象语法树</strong></p><p>回到代码的实现，我们只需要通过 <code>AST 树</code>找到 <code>await 表达式</code>，将 <code>await</code> 外面包裹一层 <code>try/catch</code> 的 Node 节点即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> asyncFunc()<br>&#125;<br></code></pre></td></tr></table></figure><p>对应 AST 树：</p><p><img src="/img/post-async-await/ast-3.webp" alt="AST 03"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> asyncFunc()<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-built_in">console</span>.log(e)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应 AST 树：</p><p><img src="/img/post-async-await/ast-4.webp" alt="AST 04"></p><h2 id="loader-开发"><a href="#loader-开发" class="headerlink" title="loader 开发"></a>loader 开发</h2><p>有了具体的思路，接下来我们开始编写 <code>loader</code>，当我们的 <code>loader</code> 接收到 <code>source</code> 文件时，通过 <code>@babel/parser</code><br>这个包可以将文件转换为 AST 抽象语法树，那么如何找到对应的 <code>await</code> 表达式呢？</p><p>这就需要另外一个 <code>babel</code> 的包 <code>@babel/traverse</code>，通过 <code>@babel/traverse</code> 可以传入一个 AST 树和一些钩子函数，随后深度遍历传入的 AST 树，当遍历的节点和钩子函数的名字相同时，会执行对应的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>)<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ast = parser.parse(source)<br><br>  traverse(ast, &#123;<br>    <span class="hljs-function"><span class="hljs-title">AwaitExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>@babel/traverse</code> 我们能够轻松的找到 <code>await</code> 表达式对应的 Node 节点，接下来就是创建一个类型为 <code>TryStatement</code> 的 Node 节点，最后 <code>await</code> 放入其中。这里还需要依赖另外一个包 <code>@babel/types</code>，可以理解为 babel 版的 loadsh 库，它提供了很多和 AST 的 Node 节点相关的辅助函数，我们需要用到其中的 <code>tryStatement</code> 方法，即创建一个 <code>TryStatement</code> 的 Node 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>)<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ast = parser.parse(source)<br><br>  traverse(ast, &#123;<br>    <span class="hljs-function"><span class="hljs-title">AwaitExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> tryCatchAst = t.tryStatement(<br>        <span class="hljs-comment">//...</span><br>      )<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tryStatement</code> 接受 3 个参数，第一个是 try 子句，第二个是 catch 子句，第三个是 finally 子句，一个完整的 try/catch 语句对应的 Node 节点看起来像这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>)<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<br><br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>)<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ast = parser.parse(source)<br><br>  traverse(ast, &#123;<br>    <span class="hljs-function"><span class="hljs-title">AwaitExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> tryCatchAst = t.tryStatement(<br>        <span class="hljs-comment">// try 子句（必需项）</span><br>        t.blockStatement([<br>          t.expressionStatement(path.node)<br>        ]),<br>        <span class="hljs-comment">// catch 子句</span><br>        t.catchClause(<br>          <span class="hljs-comment">//...</span><br>        )<br>      )<br>      path.replaceWithMultiple([<br>        tryCatchAst<br>      ])<br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>blockStatement</code> ，<code>expressionStatement</code> 方法创建一个块级作用域和承载 await 表达式的 Node 节点，<code>@babel/traverse</code> 会给每个钩子函数传入一个 <code>path</code> 参数，包含了当前遍历的一些信息，例如当前节点，上个遍历的 <code>path</code> 对象和对应的节点，最重要的是里面有一些可以操作 Node 节点的方法，我们需要使用到 <code>replaceWithMultiple</code> 这个方法来将当前的 Node 节点替换为 try/catch 语句的 Node 节点</p><p>另外我们要考虑到 await 表达式可能是是作为一个声明语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> asyncFunc()<br></code></pre></td></tr></table></figure><p>也有可能是一个赋值语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">res = <span class="hljs-keyword">await</span> asyncFunc()<br></code></pre></td></tr></table></figure><p>还有可能只是一个单纯的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">await</span> asyncFunc()<br></code></pre></td></tr></table></figure><p>这 3 种情况对应的 AST 也是不一样的，所以我们需要对其分别处理，<code>@bable/types</code> 提供了丰富的判断函数，在 <code>AwaitExpression</code> 钩子函数中，我们只需要判断上级节点是哪种类型的 Node 节点即可，另外也可以通过 <code>AST explorer</code> 来查看最终需要生成的 AST 树的结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>)<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ast = parser.parse(source)<br><br>  traverse(ast, &#123;<br>    <span class="hljs-function"><span class="hljs-title">AwaitExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (t.isVariableDeclarator(path.parent)) &#123; <span class="hljs-comment">// 变量声明</span><br>        <span class="hljs-keyword">let</span> variableDeclarationPath = path.parentPath.parentPath<br>        <span class="hljs-keyword">let</span> tryCatchAst = t.tryStatement(<br>          t.blockStatement([<br>            variableDeclarationPath.node <span class="hljs-comment">// Ast</span><br>          ]),<br>          t.catchClause(<br>            <span class="hljs-comment">//...</span><br>          )<br>        )<br>        variableDeclarationPath.replaceWithMultiple([<br>          tryCatchAst<br>        ])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.isAssignmentExpression(path.parent)) &#123; <span class="hljs-comment">// 赋值表达式</span><br>        <span class="hljs-keyword">let</span> expressionStatementPath = path.parentPath.parentPath<br>        <span class="hljs-keyword">let</span> tryCatchAst = t.tryStatement(<br>          t.blockStatement([<br>            expressionStatementPath.node<br>          ]),<br>          t.catchClause(<br>            <span class="hljs-comment">//...</span><br>          )<br>        )<br>        expressionStatementPath.replaceWithMultiple([<br>          tryCatchAst<br>        ])<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// await 表达式</span><br>        <span class="hljs-keyword">let</span> tryCatchAst = t.tryStatement(<br>          t.blockStatement([<br>            t.expressionStatement(path.node)<br>          ]),<br>          t.catchClause(<br>            <span class="hljs-comment">//...</span><br>          )<br>        )<br>        path.replaceWithMultiple([<br>          tryCatchAst<br>        ])<br>      &#125;<br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在拿到替换后的 AST 树后，使用 <code>@babel/core</code> 包中的 <code>transformFromAstSync</code> 方法将 AST 树重新转为对应的代码字符串返回即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>)<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>)<br><span class="hljs-keyword">const</span> core = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>)<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ast = parser.parse(source)<br><br>  traverse(ast, &#123;<br>    <span class="hljs-function"><span class="hljs-title">AwaitExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>      <span class="hljs-comment">// 同上</span><br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> core.transformFromAstSync(ast).code<br>&#125;<br></code></pre></td></tr></table></figure><p>在这基础上还暴露了一些 <code>loader</code> 配置项以提高易用性，例如如果 await 语句已经被 try/catch 包裹则不会再次注入，其原理也是基于 AST，利用 path 参数的 <code>findParent</code> 方法向上遍历所有父节点，判断是否被 try/catch 的 Node 包裹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">traverse(ast, &#123;<br>  <span class="hljs-function"><span class="hljs-title">AwaitExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (path.findParent(<span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> t.isTryStatement(path.node))) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 处理逻辑</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>另外 catch 子句中的代码片段也支持自定义，这样使得所有错误都使用统一逻辑处理，原理是将用户配置的代码片段转为 AST，在 <code>TryStatement</code> 节点被创建的时候作为参数传入其 catch 节点</p><h2 id="进一步改进"><a href="#进一步改进" class="headerlink" title="进一步改进"></a>进一步改进</h2><p>将默认给每个 await 语句添加一个 try/catch，修改为给整个 async 函数包裹 try/catch，原理是先找到 await 语句，然后递归向上遍历</p><p>当找到 async 函数时，创建一个 try/catch 的 Node 节点，并将原来 async 函数中的代码作为 Node 节点的子节点，并替换 async 函数的函数体</p><p>当遇到 try/catch，说明已经被 try/catch 包裹，取消注入，直接退出遍历，这样当用户有自定义的错误捕获代码就不会执行 loader 默认的捕获逻辑了</p><p><img src="/img/post-async-await/code-1.webp" alt="code 01"></p><p>对应 AST 树:</p><p><img src="/img/post-async-await/ast-5.webp" alt="AST 05"></p><p><img src="/img/post-async-await/code-2.webp" alt="code 02"></p><p>对应 AST 树：</p><p><img src="/img/post-async-await/ast-6.webp" alt="AST 06"></p><p>这只是最基本的 async 函数声明的 node 节点，另外还有函数表达式，箭头函数，作为对象的方法等这些表现形式，当满足其中一种情况就注入 try/catch 代码块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">const</span> func = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> asyncFunc()<br>&#125;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> func2 = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">await</span> asyncFunc()<br>&#125;<br><br><span class="hljs-comment">// 方法</span><br><span class="hljs-keyword">const</span> vueComponent = &#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">await</span> asyncFunc()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文意在 <strong>抛砖引玉</strong> ，在日常开发过程中，可以结合自己的业务线，开发更加适合自己的 loader，例如技术栈是 jQuery 的老项目，可以匹配 $.ajax 的 Node 节点，统一注入错误处理逻辑，甚至可以自定义一些 ECMA 没有的新语法</p><p>通过开发这个 loader 不仅可以学习到 webpack loader 是如何运行的，同时了解很多 AST 方面的知识，了解 babel 的原理，更多的方法可以查看 <a href="https://www.babeljs.cn/">babel 官方文档</a> 或者 <a href="https://github.com/jamiebuilds/babel-handbook">babel 手书</a></p>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Webpack</tag>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web前端开发规范(with React)</title>
    <link href="/2021/11/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-with-React/"/>
    <url>/2021/11/23/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-with-React/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-前端开发规范-with-React"><a href="#Web-前端开发规范-with-React" class="headerlink" title="Web 前端开发规范(with React)"></a>Web 前端开发规范(with React)</h1><blockquote><p>不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的</p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><ul><li>提高团队协作效率、便于后期优化维护、输出高质量的代码</li><li>代码即文档（编写的代码拥有一定程度的自我说明能力）</li><li>封装的函数/类、复杂组件、复杂的业务逻辑，需要书写注释，注释要求简练准确。不要写过多注释</li><li>书写 <code>ES6+</code> 的语法</li></ul><h2 id="二、环境要求"><a href="#二、环境要求" class="headerlink" title="二、环境要求"></a>二、环境要求</h2><ul><li><a href="https://nodejs.org/">Node.js</a> 12 或更高版本，你可以使用 <a href="https://github.com/creationix/nvm">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows">nvm-windows</a> 在一台电脑中管理多个 <code>Node</code> 版本</li><li>使用 <a href="https://code.visualstudio.com/">Visual Studio Code (VS Code)</a> 进行代码编写</li><li>代码提交前要保证没有运行 bug，并且要保证代码符合规范</li><li>使用 Chrome 浏览器并安装 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?utm_source=chrome-ntp-icon">React Developer Tools</a> 进行调试</li><li>使用 <code>Tab</code> 缩进，规定 Tab 大小为 <code>2 个空格</code>，保证在所有环境下获得一致展现:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// vscode settings.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;editor.tabSize&quot;</span>: <span class="hljs-number">2</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、编码规范"><a href="#三、编码规范" class="headerlink" title="三、编码规范"></a>三、编码规范</h2><h3 id="规范依据"><a href="#规范依据" class="headerlink" title="规范依据"></a>规范依据</h3><ul><li>JavaScript 代码规范: <a href="https://standardjs.com/readme-zhcn.html">JavaScript Standard Style</a></li><li>React 代码规范: <a href="https://github.com/jiahao-c/javascript/tree/master/react">Airbnb React/JSX 风格指南</a></li></ul><h3 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h3><blockquote><p>具体规则请阅读上述两篇文档，在此仅选取部分常见的规则进行强调与补充</p></blockquote><h4 id="JavaScript-常用代码规则"><a href="#JavaScript-常用代码规则" class="headerlink" title="JavaScript 常用代码规则"></a>JavaScript 常用代码规则</h4><ul><li>标准变量采用驼峰式命名（考虑与后台交换数据的情况，对象属性可灵活命名）</li><li>字符串统一使用单引号</li><li>不要定义未使用的变量</li><li>定义变量使用 <code>let</code>，定义常量使用 <code>const</code></li><li>全局性、关键性的常量全大写，用下划线连接</li><li>变量名不应过短，要能准确完整地描述该变量所表述的事物</li></ul><table><thead><tr><th>不好的变量名</th><th>好的变量名</th></tr></thead><tbody><tr><td>inp</td><td>input, priceInput</td></tr><tr><td>day1, day2, param1</td><td>today, tomorrow</td></tr><tr><td>id</td><td>userId, orderId</td></tr><tr><td>obj</td><td>orderData, houseInfos</td></tr><tr><td>tId</td><td>removeMsgTimerId</td></tr><tr><td>handler</td><td>submitHandler, searchHandler</td></tr></tbody></table><ul><li>变量名的对仗要明确，如 <code>up/down</code>、<code>begin/end</code>、<code>opened/closed</code>、<code>visible/invisible</code>、<code>scource/target</code></li><li>不要使用中文拼音，如 <code>shijianchuo</code> 应改成 <code>timestamp</code> ； 如果是复数的话加 <code>s</code>，或者加上 <code>List</code>，如 <code>orderList</code>、<code>menuItems</code>； 而过去式的加上 <code>ed</code>，如 <code>updated/found</code> 等； 如果正在进行的加上 <code>ing</code>，如 <code>calling</code></li><li>使用临时变量时请结合实际需要进行变量命名</li></ul><p><em>有些喜欢取 <code>temp</code> 和 <code>obj</code> 之类的变量，如果这种临时变量在两行代码内就用完了，接下来的代码就不会再用了，还是可以接受的，如交换数组的两个元素。但是有些人取了个 <code>temp</code>，接下来十几行代码都用到了这个 <code>temp</code>，这个就让人很困惑了。所以应该尽量少用 <code>temp</code> 类的变量</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// not good</span><br><span class="hljs-keyword">let</span> temp = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> leftPosition = currentPosition + temp，<br>    topPosition = currentPosition - temp<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">let</span> adjustSpace = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> leftPosition = currentPosition + adjustSpace<br><span class="hljs-keyword">let</span> topPosition = currentPosition - adjustSpace<br></code></pre></td></tr></table></figure><ul><li>禁止嵌套三元表达式</li><li>使用箭头函数取代简单的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// not good</span><br><span class="hljs-keyword">let</span> _this = <span class="hljs-built_in">this</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  _this.foo = <span class="hljs-string">&quot;bar&quot;</span><br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">// good</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.foo = <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><ul><li>禁止不必要的分号！！！</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&#x27;hi&#x27;</span>)   <span class="hljs-comment">// ✓ ok</span><br><span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&#x27;hi&#x27;</span>);  <span class="hljs-comment">// ✗ avoid</span><br></code></pre></td></tr></table></figure><ul><li>不要使用 <code>(</code>, <code>[</code>, or ` 等作为一行的开始，在没有分号的情况下代码压缩后会导致报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// ✓ ok</span><br>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;())<br><span class="hljs-comment">// ✗ avoid</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;())<br><br><span class="hljs-comment">// ✓ ok</span><br>;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach(bar)<br><span class="hljs-comment">// ✗ avoid</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach(bar)<br><br><span class="hljs-comment">// ✓ ok</span><br>;<span class="hljs-string">`hello`</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>)<br><span class="hljs-comment">// ✗ avoid</span><br><span class="hljs-string">`hello`</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>)<br><br><span class="hljs-comment">// 上面的正确写法是可行的，但是建议使用以下更加规范的写法</span><br><br><span class="hljs-comment">// 譬如：</span><br>;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach(bar)<br><span class="hljs-comment">// 建议的写法是：</span><br><span class="hljs-keyword">let</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>nums.forEach(bar)<br></code></pre></td></tr></table></figure><ul><li>关键字后面加空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (condition) &#123; ... &#125;   <span class="hljs-comment">// ✓ ok</span><br><span class="hljs-keyword">if</span>(condition) &#123; ... &#125;    <span class="hljs-comment">// ✗ avoid</span><br></code></pre></td></tr></table></figure><ul><li>函数声明时括号与函数名间加空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span> (<span class="hljs-params">arg</span>) </span>&#123; ... &#125;   <span class="hljs-comment">// ✓ ok</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params">arg</span>) </span>&#123; ... &#125;    <span class="hljs-comment">// ✗ avoid</span><br><br>run(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ... &#125;)      <span class="hljs-comment">// ✓ ok</span><br>run(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;)       <span class="hljs-comment">// ✗ avoid</span><br></code></pre></td></tr></table></figure><ul><li>函数调用时标识符与括号间不留间隔</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-built_in">console</span>.log (<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// ✗ avoid</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)  <span class="hljs-comment">// ✓ ok</span><br></code></pre></td></tr></table></figure><ul><li>始终使用 === 替代 ==</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;John&#x27;</span>)   <span class="hljs-comment">// ✓ ok</span><br><span class="hljs-keyword">if</span> (name == <span class="hljs-string">&#x27;John&#x27;</span>)    <span class="hljs-comment">// ✗ avoid</span><br><br><span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&#x27;John&#x27;</span>)   <span class="hljs-comment">// ✓ ok</span><br><span class="hljs-keyword">if</span> (name != <span class="hljs-string">&#x27;John&#x27;</span>)    <span class="hljs-comment">// ✗ avoid</span><br></code></pre></td></tr></table></figure><ul><li>文件末尾留一空行</li></ul><h4 id="React-相关规范"><a href="#React-相关规范" class="headerlink" title="React 相关规范"></a>React 相关规范</h4><h5 id="主要使用技术栈"><a href="#主要使用技术栈" class="headerlink" title="主要使用技术栈"></a>主要使用技术栈</h5><ul><li>UI 组件库 <a href="https://ant-design.gitee.io/index-cn">Antd</a></li><li>图表库 <a href="https://charts.ant.design/zh-CN">Ant Design Charts</a></li><li>开箱即用的中台前端/设计解决方案 <a href="https://pro.ant.design/index-cn">Ant Design Pro</a></li><li>高度封装的业务组件库 <a href="https://procomponents.ant.design/">ProComponents</a></li><li>插件化的企业级前端应用框架 <a href="https://umijs.org/zh-CN">UmiJS</a></li></ul><h5 id="React-常用代码规则"><a href="#React-常用代码规则" class="headerlink" title="React 常用代码规则"></a>React 常用代码规则</h5><p><strong>组件</strong></p><p><strong>1. 基本规则</strong></p><ul><li>一个文件最多只能包含一个 <code>class</code> 组件，可以包含多个 <code>function</code> 组件</li><li>使用 <code>JSX</code> 语法</li><li>使用 <code>class</code>、<code>function</code> 或 <code>Hooks</code> 声明组件，不使用 <code>React.createElement</code></li></ul><p><strong>2. 组件名</strong></p><ul><li>组件名称和定义该组件的文件名称尽量保持一致，名称尽量简短</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Good</span><br><span class="hljs-keyword">import</span> MyComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent&#x27;</span><br><br><span class="hljs-comment">// Bad</span><br><span class="hljs-keyword">import</span> MyComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyComponent/index&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>应在 <code>class</code>、<code>function</code>(箭头函数就是 <code>const</code> 关键字) 关键字或 声明后面直接声明组件名称,不要使用 <code>displayName</code> 来命名 <code>React</code> 模块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Good</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">const</span> MyField = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span><span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.createClass(&#123;<br>  <span class="hljs-attr">displayName</span>: <span class="hljs-string">&#x27;MyComponent&#x27;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>组件名称应全局唯一</li></ul><p><em>很多业务都会有相同的文件命名，此时应在声明组件名称时保持全局唯一。一般是将业务链路名称全拼至组件声明</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Account/User/List.jsx</span><br><br><span class="hljs-comment">// Good</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUserList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// Bad</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>高阶组件名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// Bad</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withFoo</span>(<span class="hljs-params">WrappedComponent</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WithFoo</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">foo</span> /&gt;</span></span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Good</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withFoo</span>(<span class="hljs-params">WrappedComponent</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WithFoo</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...props</span>&#125; <span class="hljs-attr">foo</span> /&gt;</span></span><br>  &#125;<br><br>  <span class="hljs-keyword">const</span> wrappedComponentName =<br>    WrappedComponent.displayName || WrappedComponent.name || <span class="hljs-string">&#x27;Component&#x27;</span><br><br>  WithFoo.displayName = <span class="hljs-string">`withFoo(<span class="hljs-subst">$&#123;wrappedComponentName&#125;</span>)`</span><br>  <span class="hljs-keyword">return</span> WithFoo<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1. 组件文件名</strong></p><ul><li>组件文件后缀为 <code>jsx</code>、<code>tsx</code></li><li>组件文件名为 <code>PascalCase</code> 大驼峰格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">components/<br>|- MyComponents.jsx<br></code></pre></td></tr></table></figure><ul><li>组件文件夹名称和默认导出一个组件可以被拆分成多个组件编写的应建立目录，目录使用 PascalCase。建立 index.jsx 导出对象</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">components/<br>|- MyComponent/<br>|----index.jsx<br>|----MyComponentList.jsx<br>|----MyComponentListItem.jsx<br></code></pre></td></tr></table></figure><p><strong>4. Hooks</strong></p><ul><li><code>Function</code> + <code>Hooks</code> 形式的组件优先，尽量少写 <code>Class</code> 组件</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// Good</span><br><span class="hljs-keyword">import</span> React, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; Modal, Form, Checkbox &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br><br><span class="hljs-keyword">const</span> AutoModal = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; visible, formItemLayout, customerFlag, csFlag &#125; = props<br>  <span class="hljs-keyword">const</span> [confirmLoading, setConfirmLoading] = useState(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> [form] = Form.useForm()<br>  <span class="hljs-keyword">const</span> [csFlagState, setCsFlagState] = useState(csFlag)<br>  <span class="hljs-keyword">const</span> [customerFlagState, setCustomerFlagState] = useState(customerFlag)<br>  <span class="hljs-keyword">const</span> handleFinish = <span class="hljs-keyword">async</span> values =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      setConfirmLoading(<span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">await</span> handleOk(values)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-built_in">console</span>.error(e)<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      setConfirmLoading(<span class="hljs-literal">false</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> handleOk = <span class="hljs-function">() =&gt;</span> &#123;<br>    form.submit()<br>  &#125;<br>  <span class="hljs-keyword">const</span> handleCancel = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <span class="hljs-keyword">const</span> handleCSFlagChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    setCsFlagState(e.target.checked)<br>  &#125;<br>  <span class="hljs-keyword">const</span> handleCustomerFlagChange = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    setCustomerFlagState(e.target.checked)<br>  &#125;<br>  <span class="hljs-keyword">const</span> checkFlag = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (csFlagState || customerFlagState) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>    &#125;<br>    message.warning(<span class="hljs-string">&#x27;服务客服或服务客户至少选一项&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;服务客服或服务客户至少选一项&#x27;</span>))<br>  &#125;<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 使用visible防止出现useForm报错</span><br>    <span class="hljs-keyword">if</span> (visible) &#123;<br>      form.setFieldsValue(&#123;<br>        <span class="hljs-attr">newTskId</span>: modifyObj.tskId,<br>        <span class="hljs-attr">creIdList</span>: modifyObj.creIdList,<br>        <span class="hljs-attr">custIdList</span>: modifyObj.custIdList,<br>      &#125;)<br>    &#125;<br>  &#125;, [modifyObj, visible, form])<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (visible) &#123;<br>      form.setFieldsValue(&#123;<br>        csFlag,<br>      &#125;)<br>      setCsFlagState(csFlag)<br>    &#125;<br>  &#125;, [csFlag, visible, form])<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (visible) &#123;<br>      form.setFieldsValue(&#123;<br>        <span class="hljs-attr">customeFlag</span>: customerFlag,<br>      &#125;)<br>      setCustomerFlagState(customerFlag)<br>    &#125;<br>  &#125;, [customerFlag, visible, form])<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Modal</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">forceRender</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;title&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">visible</span>=<span class="hljs-string">&#123;visible&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onOk</span>=<span class="hljs-string">&#123;handleOk&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">confirmLoading</span>=<span class="hljs-string">&#123;confirmLoading&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">onCancel</span>=<span class="hljs-string">&#123;handleCancel&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">destroyOnClose</span></span></span><br><span class="hljs-tag"><span class="xml">    &gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">form</span>=<span class="hljs-string">&#123;form&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">preserve</span>=<span class="hljs-string">&#123;false&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">onFinish</span>=<span class="hljs-string">&#123;handleFinish&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">        &#123;<span class="hljs-attr">...formItemLayout</span>&#125;</span></span><br><span class="hljs-tag"><span class="xml">      &gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Form.Item</span></span></span><br><span class="hljs-tag"><span class="xml">          &#123;<span class="hljs-attr">...formItemLayout</span>&#125;</span></span><br><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginBottom:</span> <span class="hljs-attr">0</span> &#125;&#125;</span></span><br><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="xml">            &lt;<span class="hljs-attr">Form.Item</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">noStyle</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;csFlag&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">rules</span>=<span class="hljs-string">&#123;[&#123;</span> <span class="hljs-attr">validator:</span> <span class="hljs-attr">checkFlag</span> &#125;]&#125;</span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">validateTrigger</span>=<span class="hljs-string">&quot;onSubmit&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">initialValue</span>=<span class="hljs-string">&#123;csFlagState&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">valuePropName</span>=<span class="hljs-string">&quot;checked&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">            &gt;</span></span><br><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">Checkbox</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleCSFlagChange&#125;</span>&gt;</span>&#123;csLabel&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Checkbox</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Form.Item</span>&gt;</span></span><br><span class="xml">          &#125;</span><br><span class="xml">        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Form.Item</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Form.Item</span></span></span><br><span class="hljs-tag"><span class="xml">          &#123;<span class="hljs-attr">...formItemLayout</span>&#125;</span></span><br><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">marginBottom:</span> <span class="hljs-attr">0</span> &#125;&#125;</span></span><br><span class="hljs-tag"><span class="xml">          <span class="hljs-attr">label</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="xml">            &lt;<span class="hljs-attr">Form.Item</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">noStyle</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customeFlag&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">rules</span>=<span class="hljs-string">&#123;[&#123;</span> <span class="hljs-attr">validator:</span> <span class="hljs-attr">checkFlag</span> &#125;]&#125;</span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">validateTrigger</span>=<span class="hljs-string">&quot;onSubmit&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">initialValue</span>=<span class="hljs-string">&#123;customerFlagState&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">              <span class="hljs-attr">valuePropName</span>=<span class="hljs-string">&quot;checked&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">            &gt;</span></span><br><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">Checkbox</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleCustomerFlagChange&#125;</span>&gt;</span></span><br><span class="xml">                &#123;customerLabel&#125;</span><br><span class="xml">              <span class="hljs-tag">&lt;/<span class="hljs-name">Checkbox</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Form.Item</span>&gt;</span></span><br><span class="xml">          &#125;</span><br><span class="xml">        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Form.Item</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">Form</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Modal</span>&gt;</span></span><br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AutoModal<br></code></pre></td></tr></table></figure><p><strong>5. 组件中的命名规则</strong></p><ul><li>属性名称： 使用小驼峰命名</li><li>style 样式： 使用小驼峰命名的样式属性</li></ul><p><strong>6. 组件样式</strong></p><ul><li>使用 <code>CSS Modules</code> 编写局部样式组件，因为其对象是作为对象在 jsx 中使用，样式应使用小驼峰命名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">.myWrapper &#123;<br>  &amp;-Text &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;style.less&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.myWrapper&#125;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.myWrapperText&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识 TensorFlow</title>
    <link href="/2021/10/30/%E5%88%9D%E8%AF%86-TensorFlow/"/>
    <url>/2021/10/30/%E5%88%9D%E8%AF%86-TensorFlow/</url>
    
    <content type="html"><![CDATA[<h1 id="初识-TensorFlow"><a href="#初识-TensorFlow" class="headerlink" title="初识 TensorFlow"></a>初识 TensorFlow</h1><ol><li>了解引入的需要神经网络解决的问题</li><li>学习用神经网络的基本结构、表达方式和编程实现</li><li>学习训练神经网络的基本方法</li></ol><h2 id="三好学生成绩问题"><a href="#三好学生成绩问题" class="headerlink" title="三好学生成绩问题"></a>三好学生成绩问题</h2><p>总分 = 德育分 * 60% + 智育分 * 30% + 体育分 * 10%  </p><p>假设家长不知道这个规则，已知：</p><ul><li>学校一定是以德育分、智育分和体育分三项分数的总分来确定三好学生的</li><li>计算总分时，三项分数应该有各自的权重系数</li><li>各自孩子的三项分数都已经知道，总分也已经知道</li></ul><p>经过家长们的分析，只有三项分数各自乘以的权重系数是未知的。问题演变成求解方程：w1x + w2y + w3z = A 中的三个 w 即权重。其中 x、y、z、A 分别对应几位学生的德育分、智育分、体育分和总分。  </p><p>两个方程式解三个未知数无法求解：  </p><p><code>90w1 + 80w2 + 70w3 = 85</code><br><code>98w1 + 95w2 + 87w3 = 96</code>  </p><h2 id="搭建对应的网络神经"><a href="#搭建对应的网络神经" class="headerlink" title="搭建对应的网络神经"></a>搭建对应的网络神经</h2><p>神经网络模型图的一般约定：  </p><ul><li>神经网络图一般包含一个输入层、一个或多个隐藏层，以及一个输出层</li><li>输入层是描逑输入数据的形态的（输入节点）</li><li>隐藏层是描迒神经网络模型结构中最重要的部分隐藏层可以有多个；每一层有一个或多个神经元（神经元节点/节点）；每个节点接收上层的数据并进行运算向下层输出数据（计算操作/操作）</li><li>输出层一般是神经网络的最后一层，包含一个或多个输出节点</li></ul><p><img src="/img/post-tf/model.png" alt="神经网络模型"></p><p>神经网络的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br>x1 = tf.placeholder(dtype = tf.float32)<br>x2 = tf.placeholder(dtype = tf.float32)<br>x3 = tf.placeholder(dtype = tf.float32)<br><br>w1 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br>w2 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br>w3 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br><br>n1 = x1 * w1<br>n2 = x2 * w2<br>n3 = x3 * w3<br><br>y = n1 + n2 + n3<br><br>sess = tf.Session()<br>init = tf.global_variable_initializer()<br><br>sess.run(init)<br><br>result = sess.run([x1, x2, x3, w1, w2, w3, y], feed_dict=&#123;x1: <span class="hljs-number">90</span>, x2: <span class="hljs-number">80</span>, x3: <span class="hljs-number">70</span>&#125;)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>其中  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x1 = tf.placeholder(dtype = tf.float32)<br>x2 = tf.placeholder(dtype = tf.float32)<br>x3 = tf.placeholder(dtype = tf.float32)<br></code></pre></td></tr></table></figure><p>通过 <code>tf.placeholder</code> 定义三个占位符（placeholder），作为神经网络的输入节点，来准备分别接收德育、智育、体育三门分数作为神经网络的输入。dtype 是 data type 的缩写，<code>dtype = tf.float3</code> 是命令参数，<code>tf.float32</code> 代表 32 位小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">w1 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br>w2 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br>w3 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br></code></pre></td></tr></table></figure><p>通过 <code>tf.Variable()</code> 定义三个可变参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">n1 = x1 * w1<br>n2 = x2 * w2<br>n3 = x3 * w3<br></code></pre></td></tr></table></figure><p>n1、n2、n3 是三个隐藏层节点，实际上是他们的计算算式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y = n1 + n2 + n3<br></code></pre></td></tr></table></figure><p>定义输出节点 y，也就是总分的计算公式（加权求和）。至此，神经网络模型的定义完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sess = tf.Session()<br></code></pre></td></tr></table></figure><p>定义神经网络的会话对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">init = tf.global_variable_initializer()<br></code></pre></td></tr></table></figure><p><code>tf.global_variable_initializer()</code> 返回专门用于初始化可变参数的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sess.run(init)<br></code></pre></td></tr></table></figure><p>初始化所有的可变参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">result = sess.run([x1, x2, x3, w1, w2, w3, y], feed_dict=&#123;x1: <span class="hljs-number">90</span>, x2: <span class="hljs-number">80</span>, x3: <span class="hljs-number">70</span>&#125;)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><code>[x1, x2, x3, w1, w2, w3, y]</code> 为要查看的结果项，<code>feed_dict=&#123;x1: 90, x2: 80, x3: 70&#125;</code> 为输入的数据。输入三门分数运行神经网络并获得该神经网络输出的节点值。</p><p>运行代码，查看结果：  </p><p><img src="/img/post-tf/result-1.png" alt="result-1"></p><p>根据随意设置的可变参数初始值计算出的输出结果正确，证明搭建的神经网络可以运行，但不能真正投入使用，存在一定误差。  </p><h2 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h2><p>神经网络在投入使用前，都要经过训练（train）的过程才能有准确的输出。</p><ul><li>神经网络训练时一定要有训练数据</li><li>有监督学习中，训练数据中的每一条是由一组输入值和一个目标值组成的</li><li>目标值就是根据这一组输入数值应该得到的 “准答案”</li><li>一般来说，训练数据越多、离散性（覆盖面）越强越好</li></ul><p><img src="/img/post-tf/train.png" alt="train"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x1 = tf.placeholder(dtype = tf.float32)<br>x2 = tf.placeholder(dtype = tf.float32)<br>x3 = tf.placeholder(dtype = tf.float32)<br><br>yTrain = tf.placeholder(dtype = tf.float32)<br></code></pre></td></tr></table></figure><p>给神经网络增加一个输入项 —— 目标值 <code>yTrain</code>，用来表示正确的总分结果。增加误差函数 <code>loss</code>，优化器 <code>optimizer</code> 和训练对象 <code>train</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">y = n1 + n2 + n3<br><br>loss = tf.<span class="hljs-built_in">abs</span>(y - yTrain)<br>optimizer = tf.train.RMSPropOptimizer(<span class="hljs-number">0.001</span>)<br>train = optimizer.minimize(loss)<br></code></pre></td></tr></table></figure><p><code>tf.abs</code> 函数用于取绝对值：计算结果 <code>y</code> 与目标值 <code>yTrain</code> 之间的误差。使用 <code>RMSProp</code> 优化器其中参数是学习率。<code>optimizer.minimize</code> 让优化器按照把 <code>loss</code> 最小化的原则来调整可变参数。</p><blockquote><p>“误差函数”（又叫损失函数）用于让神经网络来判断当前网络的计算结果与目标值（也就是标准答案）相差多少。“训练对象”被神经网络用于控制训练的方式，常见的训练的方式是设法使误差函数的计算值越来越小。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">result = sess.run([train, x1, x2, x3, w1, w2, w3, y, yTrain], feed_dict=&#123;x1: <span class="hljs-number">90</span>, x2: <span class="hljs-number">80</span>, x3: <span class="hljs-number">70</span>, yTrain: <span class="hljs-number">96</span>&#125;)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>训练两次并查看输出结果，注意与前面的区别：训练时要在 <code>sess.run</code> 函数的第一个参数中添加 <code>train</code> 这个训练对象；在 <code>feed_dict</code> 参数中多指定了 <code>Train</code> 的数值。</p><p><img src="/img/post-tf/result-2.png" alt="result-2"></p><p>w1、w2、w3 和计算结果 y 已经开始有了变化。  </p><p>循环进行多次训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    result = sess.run([train, x1, x2, x3, w1, w2, w3, y, yTrain], feed_dict=&#123;x1: <span class="hljs-number">90</span>, x2: <span class="hljs-number">80</span>, x3: <span class="hljs-number">70</span>, yTrain: <span class="hljs-number">85</span>&#125;)<br>    <span class="hljs-built_in">print</span>(result)<br><br>    result = sess.run([train, x1, x2, x3, w1, w2, w3, y, yTrain], feed_dict=&#123;x1: <span class="hljs-number">98</span>, x2: <span class="hljs-number">95</span>, x3: <span class="hljs-number">87</span>, yTrain: <span class="hljs-number">96</span>&#125;)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><img src="/img/post-tf/result-3.png" alt="result-3"></p><p>w1、w2、w3 已经非常接近于预期的 0.6、0.3、0.1，y 也非常接近目标值。</p><p><strong>如果你使用了 TensorFlow 2.x，上述代码中可能存在兼容问题，但是可以通过更改部分代码解决：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># import tensorflow as tf</span><br><span class="hljs-keyword">import</span> tensorflow.compat.v1 <span class="hljs-keyword">as</span> tf<br><br>tf.disable_v2_behavior()<br><br>x1 = tf.placeholder(dtype = tf.float32)<br>x2 = tf.placeholder(dtype = tf.float32)<br>x3 = tf.placeholder(dtype = tf.float32)<br><br>yTrain = tf.placeholder(dtype = tf.float32)<br><br>w1 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br>w2 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br>w3 = tf.Variable(<span class="hljs-number">0.1</span>, dtype = tf.float32)<br><br>n1 = x1 * w1<br>n2 = x2 * w2<br>n3 = x3 * w3<br><br>y = n1 + n2 + n3<br><br>loss = tf.<span class="hljs-built_in">abs</span>(y - yTrain)<br>optimizer = tf.train.RMSPropOptimizer(<span class="hljs-number">0.001</span>)<br>train = optimizer.minimize(loss)<br><br>sess = tf.Session()<br><span class="hljs-comment"># init = tf.global_variables_initializer()</span><br>init = tf.compat.v1.global_variables_initializer()<br><br>sess.run(init)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    result = sess.run([train, x1, x2, x3, w1, w2, w3, y, yTrain], feed_dict=&#123;x1: <span class="hljs-number">90</span>, x2: <span class="hljs-number">80</span>, x3: <span class="hljs-number">70</span>, yTrain: <span class="hljs-number">85</span>&#125;)<br>    <span class="hljs-built_in">print</span>(result)<br><br>    result = sess.run([train, x1, x2, x3, w1, w2, w3, y, yTrain], feed_dict=&#123;x1: <span class="hljs-number">98</span>, x2: <span class="hljs-number">95</span>, x3: <span class="hljs-number">87</span>, yTrain: <span class="hljs-number">96</span>&#125;)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TensorFlow</tag>
      
      <tag>机器学习</tag>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
